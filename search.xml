<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用electron制作你的第一个桌面应用]]></title>
    <url>%2F2019%2F06%2F05%2F%E7%94%A8electron%E5%88%B6%E4%BD%9C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron是什么？Electron由 Github 开发，使用Chromium和Node.js的跨平台桌面应用程序的框架。能够非常容易的使用HTML、CSS和JavaScript构建，并能与Mac、windows、linux兼容。 其他内置功能包括: 自动更新 本机菜单和通知 应用程序崩溃报告 调试和分析 Windows安装程序 本文章将制作一个简单的按键发声的electron应用。源码地址 在我们开始先，你需要安装Node.js。而且应该有一个Github账号来存储更新你的应用。 从这里开始当我们安装好node环境，并设置完毕后，打开操作终端窗口。 按照下面的方式快速启动一个electron。我们将在这个基础上构建我们的软件。 123456# 克隆示例项目的仓库git clone https://github.com/electron/electron-quick-start# 进入这个仓库cd electron-quick-start# 安装依赖并运行npm install &amp;&amp; npm start 当上面列出的步骤完成后，你会看到应用程序在浏览器窗口中打开。这确实是一个浏览器窗口。 正如前面所说，你可以在你的应用程序中使用Chrome的开发者工具。你可以用浏览器的开发者工具做什么，你也可以在应用程序中做什么。 Electron应用架构用你喜欢的IDE打开项目，来看看程序的源码和文件结构，这里使用的是Atom，同时它也是基于electron制作的。 现在就有了一个基本的文件结构 12345electron-quick-start- index.html- main.js- package.json- render.js 文件结构类似于我们创建网页时使用的文件结构。 index.html 如同页面开发一样，我们的主体，装载各种dom元素。 main.js 创建窗口并处理系统事件 package.json 是我们应用程序的启动脚本。它将在主进程中运行，并且包含关于我们的应用程序的信息 render.js 处理应用程序的渲染过程 你可能有一些关于主流程和渲染流程的问题。这是什么玩意，我该怎么用。因为如果你原来只擅长JavaScript，这可能是个新领域。 什么是进程当你看到“进程”时，想想操作系统级的进程。这是在系统中运行的计算机程序的一个实例。 如果启动Electron，并检查Windows任务管理器或者macOS的活动监视器，可以看到与我的应用程序相关的进程。 这些进程中的每一个都是并行运行的。但是分配给每个进程的内存和资源是相互隔离的。 比方说，我想创建一个for循环，在渲染过程中增加一些内容。 1234var a = 1;for ( a = 1; a &lt; 10; a ++) &#123; console.log(&apos;This is a for loop&apos;);&#125; 增量仅在渲染过程中可用。它根本不影响主要过程。This is a for loop这个信息只会出现在渲染模块上。 Main Process主进程控制应用程序的生命周期。它内置了完整的Node.js API，它打开对话框，并创建渲染过程。它还处理其他操作系统交互，并启动和退出应用程序。 按照惯例，这个过程在一个名为main.js的文件中，但是它可以有你想要的任何名称。 你也可以通过在package.json文件中修改主进程文件来改变它。 为了测试目的，打开package.json 将： 1“main”: “main.js”, 改成 1“main”: “mainTest.js”, 启动你的应用程序，看看它是否仍然有效。 请记住，只有一个Main Process。 Render Process渲染过程是应用程序中的浏览器窗口。与主进程不同，可以有许多渲染进程，每个进程都是独立的。 因为每个渲染过程都是独立的，所以一个渲染过程中的崩溃不会影响另一个渲染过程。这要归功于Chromium的多进程结构。 这些浏览器窗口也可以隐藏和定制，因为它们像HTML文件。 但是在Electron中，我们也有完整的node. js API。这意味着我们可以打开对话框和其他操作系统交互。 问题是，他们能以某种方式联系起来吗？ 这些进程同时独立运行。但是他们仍然需要以某种方式交流。尤其是因为他们负责不同的任务。 为此，有一个进程间通信系统或叫做IPC。您可以使用IPC在主进程和渲染进程之间传递消息。要更深入地解释这个系统，请阅读Christian Engvall的文章。 这些就是Electron开发的基本流程。 现在开始回到代码上。 个性化给文件夹起一个正确的名字。把 electron-quick-start改成 hear-me-type-tutorial。 package.json 包含关于我们的应用程序的重要信息。这是定义名称、版本、主文件、作者、许可证等等的地方。 找到下面的名称和描述，并在包中更改它们。 现在，我们的应用程序有了新的名称和简短但直截了当的描述。 记住，你总是可以在你的终端上运行npm start来执行应用程序，并查看你所做的更改。 现在开始添加我们预期的功能，按下每一个键盘，播放特定声音。 添加功能为了让应用程序对我们的输入做出反应，我们必须首先定义一个要挂钩的元素，然后触发所需的动作。 为此，我们将为我们想要的键盘按键创建带有特定标识的音频元素。然后，我们将创建一个switch语句来找出按下了哪个键盘键。然后，我们将播放分配给该键的特定声音 下载这个包含我们将要使用的所有声音文件的压缩包。我们很快就会利用它们！ 打开index.html文件，让我们创建元素，将声音内容嵌入到我们的应用程序中。 在 元素里创建一个 div 并加上audio的class。 在创建的div元素中，创建一个id为“A”、source为“sounds/A.mp3”、preload为“auto”的元素。 我们将使用preload=&quot;auto &quot;告诉应用程序，当页面加载时，它应该加载整个音频文件。index.html是应用程序的主文件，当应用程序执行时，我们所有的声音文件都会加载。 代码应该如下所示: 123&lt;div class=&quot;audio&quot;&gt;&lt;audio id=&quot;A&quot; src=&quot;sounds/A.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 现在， 指向一个未知的源文件。创建一个名为sounds的文件夹，并解压缩该文件夹中的所有声音文件。 现在唯一缺少的就是js代码。 创建一个名为functions.js的新文件。并在index.html文件中引入它，这样js代码就可以在应用程序运行时使用了。 添加下面这行代码： 1require(&apos;./functions.js&apos;) 此时项目如下图所示： 打开function.js文件，并将以下JavaScript代码添加到文件中。一会儿我会解释它是如何工作的。 123456789document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 65: document.getElementById(&apos;A&apos;).play(); break; default: console.log(&quot;Key is not found!&quot;); &#125;&#125;; 打开你的bash或终端窗口。确保你在项目的文件夹中，键入npm start 开始运行应用程序。 调整扬声器的音量，然后按键盘上的A按钮。 你就能听到一个女人的声音了。 JS代码非常简单明了。 我们使用 document 上的onkeydown事件来找出正在访问的HTML元素。请记住， document 是我们应用程序的主窗口。 在匿名函数中，我们使用switch语句。其目的是识别按下键盘键的Unicode值。 如果按下的键盘键的Unicode值正确，则会播放声音。否则，“not found”将引发错误。在控制台中查找消息。 接下来把所有键盘都给弄上声音吧。 打开index.html，为我们有声音文件的每个键创建一个元素。 代码应该如下所示: 1234567891011121314151617181920212223242526272829303132333435&lt;audio id=&quot;B&quot; src=&quot;sounds/B.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;C&quot; src=&quot;sounds/C.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;D&quot; src=&quot;sounds/D.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;E&quot; src=&quot;sounds/E.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;F&quot; src=&quot;sounds/F.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;G&quot; src=&quot;sounds/G.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;H&quot; src=&quot;sounds/H.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;I&quot; src=&quot;sounds/I.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;J&quot; src=&quot;sounds/J.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;K&quot; src=&quot;sounds/K.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;L&quot; src=&quot;sounds/L.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;M&quot; src=&quot;sounds/M.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;N&quot; src=&quot;sounds/N.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;O&quot; src=&quot;sounds/O.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;P&quot; src=&quot;sounds/P.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Q&quot; src=&quot;sounds/Q.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;R&quot; src=&quot;sounds/R.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;S&quot; src=&quot;sounds/S.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;T&quot; src=&quot;sounds/T.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;U&quot; src=&quot;sounds/U.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;V&quot; src=&quot;sounds/V.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;W&quot; src=&quot;sounds/W.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;X&quot; src=&quot;sounds/X.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Y&quot; src=&quot;sounds/Y.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Z&quot; src=&quot;sounds/Z.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;0&quot; src=&quot;sounds/0.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;1&quot; src=&quot;sounds/1.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;2&quot; src=&quot;sounds/2.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;3&quot; src=&quot;sounds/3.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;4&quot; src=&quot;sounds/4.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;5&quot; src=&quot;sounds/5.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;6&quot; src=&quot;sounds/6.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;7&quot; src=&quot;sounds/7.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;8&quot; src=&quot;sounds/8.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;9&quot; src=&quot;sounds/9.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt; 对functions.js做同样的事： 你可以在这个网站上找到字符代码(key codes)。（可能需要科学上网） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 48: document.getElementById(&apos;0&apos;).play(); break; case 49: document.getElementById(&apos;1&apos;).play(); break; case 50: document.getElementById(&apos;2&apos;).play(); break; case 51: document.getElementById(&apos;3&apos;).play(); break; case 52: document.getElementById(&apos;4&apos;).play(); break; case 53: document.getElementById(&apos;5&apos;).play(); break; case 54: document.getElementById(&apos;6&apos;).play(); break; case 55: document.getElementById(&apos;7&apos;).play(); break; case 56: document.getElementById(&apos;8&apos;).play(); break; case 57: document.getElementById(&apos;9&apos;).play(); break; case 65: document.getElementById(&apos;A&apos;).play(); break; case 66: document.getElementById(&apos;B&apos;).play(); break; case 67: document.getElementById(&apos;C&apos;).play(); break; case 68: document.getElementById(&apos;D&apos;).play(); break; case 69: document.getElementById(&apos;E&apos;).play(); break; case 70: document.getElementById(&apos;F&apos;).play(); break; case 71: document.getElementById(&apos;G&apos;).play(); break; case 72: document.getElementById(&apos;H&apos;).play(); break; case 73: document.getElementById(&apos;I&apos;).play(); break; case 74: document.getElementById(&apos;J&apos;).play(); break; case 75: document.getElementById(&apos;K&apos;).play(); break; case 76: document.getElementById(&apos;L&apos;).play(); break; case 77: document.getElementById(&apos;M&apos;).play(); break; case 78: document.getElementById(&apos;N&apos;).play(); break; case 79: document.getElementById(&apos;O&apos;).play(); break; case 80: document.getElementById(&apos;P&apos;).play(); break; case 81: document.getElementById(&apos;Q&apos;).play(); break; case 82: document.getElementById(&apos;R&apos;).play(); break; case 83: document.getElementById(&apos;S&apos;).play(); break; case 84: document.getElementById(&apos;T&apos;).play(); break; case 85: document.getElementById(&apos;U&apos;).play(); break; case 86: document.getElementById(&apos;V&apos;).play(); break; case 87: document.getElementById(&apos;W&apos;).play(); break; case 88: document.getElementById(&apos;X&apos;).play(); break; case 89: document.getElementById(&apos;Y&apos;).play(); break; case 90: document.getElementById(&apos;Z&apos;).play(); break; default: console.log(&quot;Key is not found!&quot;); &#125;&#125;; 现在我们的app完成了。 该应用程序的主要功能已经完成，但仍有工作要做！ 快结束了尽管该应用程序运行正常，但它仍然缺少一些东西。 例如，在index.html文件中，您可以更改应用程序的标题和主窗口的内容。还可以增加各种样式。 代码也不完美。我们有许多相同的代码可以优化和改进。这将导致代码行减少，对眼睛来说也不会那么痛苦。 重复代码是不好的做法。 试一试?好的软件必须经过彻底的测试。 我建议你先按下每一个键盘键看看发生了什么。 最好的情况是你会听到你在代码中指定的每个键盘键的声音。但是，当你尽可能快地连续按下多个键时，会发生什么呢？像Home和NumLock按钮这样甚至不应该被按下的按键呢？ 如果你最小化应用程序并试着按下一个键会怎么样？你听到声音了吗？当你没有选择应用程序窗口，按下键盘键，你还能听到任何声音吗？ 不幸的是，答案是否定的。 这种行为是因为electron的构建。它允许你像使用C#语言一样获得全局键，但是你不能注册单独的键击。这超出了electron的正常用例范围。 一行接一行地运行代码，并尝试破解它。看看正在发生什么，electron正在抛出什么样的错误。这个练习将帮助你更好地调试。如果你知道你的应用程序的缺陷，那么你就知道如何修复它们，使应用程序变得更好。 在function.js文件中，我特意使用了一个不推荐使用的JavaScript事件。你能认出它吗？ 一旦你找到它，我希望你考虑如何在不改变应用程序功能的情况下替换它。 使用不推荐的代码是一种不好的做法，可能会导致严重的错误，你甚至可能不知道存在。随时了解语言的文档，看看会有什么变化。永远保持最新。 翻译自原文地址]]></content>
  </entry>
</search>
