<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js备忘录]]></title>
    <url>%2F2019%2F06%2F11%2Fjs%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[appendChild123let img = document.createElement(&quot;img&quot;)...resultArea.appendChild(img); classList contains1234567891011&lt;div id=&quot;div1&quot; class=&quot;class1 class3&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;script&gt;a=document.getElementById(&quot;div1&quot;);b=document.getElementById(&quot;div2&quot;);c=a.classList.contains(&quot;class1&quot;);d=a.classList.contains(&quot;class2&quot;);e=a.classList.contains(&quot;class3&quot;);b.textContent=c.toString()+&quot; &quot;+d.toString()+&quot; &quot;+e.toString();&lt;/script&gt; className123result.className = &quot;result&quot;;...name.className = &quot;name&quot;; CSS变量1task.line.parentElement.style.setProperty(&quot;--max-delay&quot;, maxDelay); for in123456var person = &#123;fname:&quot;jone&quot;,lname:&quot;Doe&quot;,age:25&#125;var text= &apos;&apos;var x;for(x in person)&#123; text +=person[x] + &quot;&quot;;&#125; forEach123456array.forEach(function (item, i) &#123;// The following code logs a line for each element in an array:// function logArrayElements(element, index, array) &#123;// console.log(&apos;a[&apos; + index + &apos;] = &apos; + element);// &#125;// HTML转换为文本12345&lt;script&gt;a=&quot;&lt;span&gt;AAAAA&lt;/span&gt;&lt;div&gt;BBBBB&lt;/div&gt;&quot;;a=a.replace(/&lt;(?:.|\n)*?&gt;/gm, &apos;&apos;);console.log(a);&lt;/script&gt; isNaN123const b = parseFloat(a.substring(i+1,j));if(isNaN(b)) &#123;... JSON格式12345678910111213141516data1 = &#123; Vultr: [&#123; name: &quot;Frankfurt&quot;, url: &quot;http://fra-de-ping.vultr.com/&quot;, download: &quot;http://fra-de-ping.vultr.com/vultr.com.100MB.bin&quot; &#125;, &#123; name: &quot;Amsterdam&quot;, url: &quot;http://ams-nl-ping.vultr.com/&quot;, download: &quot;http://ams-nl-ping.vultr.com/vultr.com.100MB.bin&quot; &#125;, ... &quot;EC2 (No Download)&quot;: [&#123; name: &quot;North Virginia&quot;, url: &quot;http://18.204.0.0/&quot; &#125;, ... Object.entries forEach123456789101112131415Object.entries(data).forEach(function (pair) &#123; // Object.entries... // const object2 = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; &#125;; // console.log(Object.entries(object2)[2]); // expected output: Array [&quot;2&quot;, &quot;c&quot;] // // forEach... // var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; // array1.forEach(function(element) &#123; // console.log(element); // &#125;); // expected output: &quot;a&quot; // expected output: &quot;b&quot; // expected output: &quot;c&quot; // Object.keys1234dataKeys = Object.keys(data);for(i=0;i&lt;=dataKeys.length-1;i++) &#123; dataEntry = data[dataKeys[i]];... parseInt1234&lt;script&gt;var n = parseInt(&quot;2018@geeksforgeeks&quot;);console.log(n); //2018&lt;/script&gt; push12345tasks.push(subtasks);// The push() method adds one or more elements// to the end of an array// and returns the new length of the array.// querySelector1const resultArea = document.querySelector(&quot;#result&quot;); querySelectorAll12345678910111213&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;&lt;script&gt;a=document.querySelectorAll(&quot;.a&quot;);for(i=0;i&lt;=a.length-1;i++) &#123; a[i].innerHTML=123;&#125;//123//123//123&lt;/script&gt; requestAnimationFrame1234567891011let nextTick = window.requestAnimationFrame || window.setTimeout// The delay function// The window.requestAnimationFrame() method tells the browser// that you wish to perform an animation and requests// that the browser call a specified function// to update an animation before the next repaint.//...function handleTasks() &#123;...nextTick(handleTasks); shift12345currentSubTasks = tasks.shift();...// The shift() method removes the first element// from an array and returns that removed element.// sort123newRankListSort.sort(function (a,b) &#123; return a.milliseconds - b.milliseconds;&#125;); splice1234567&lt;script&gt;var list = [&quot;foo&quot;, &quot;bar&quot;];list.splice(1, 0, &quot;baz&quot;, &quot;qux&quot;);console.log(list); // (4) [&quot;foo&quot;, &quot;baz&quot;, &quot;qux&quot;, &quot;bar&quot;]list.splice(1,2);console.log(list);//(2) [&quot;foo&quot;, &quot;bar&quot;]&lt;/script&gt; textContent12const el = document.createElement(tag);el.textContent = text; toFixed1document.getElementById(&quot;speed&quot;).innerText = (mb/seconds).toFixed(3).toString() + &quot; MBps&quot;; void(0)获取undefinedvoid 运算符 对给定的表达式进行求值，然后返回 undefined。 1void 0 === undefined //true undefined在JavaScript中并不属于保留字/关键字，因此在IE5.5~8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效） 这个运算符能向期望一个表达式的值是undefined的地方插入会产生副作用的表达式。 void 运算符通常只用于获取 undefined的原始值，一般使用void(0)（等同于void 0）。在上述情况中，也可以使用全局变量undefined来代替（假定其仍是默认值）。 “…”1Math.max(...this.state.millisecondsOfTargets) 保存this然后回调函数使用12345678910111213let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; let self = this console.log(this.myVar) setTimeout(function() &#123; console.log(self.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... foo 判断变量类型12345678910&lt;script&gt;a=&#123;&#125;;b=[];c=1;d=&quot;a&quot;;console.log(Object.prototype.toString.call(a)); //[object Object]console.log(Object.prototype.toString.call(b)); //[object Array]console.log(Object.prototype.toString.call(c)); //[object Number]console.log(Object.prototype.toString.call(d)); //[object String]&lt;/script&gt; 判断字符串是否为数字12345678910isNaN(num) //如果是数字的话返回falseisNaN(123) //falseisNaN(&apos;123&apos;) //falseisNaN(&apos;1e10000&apos;) //false (被转义成 Infinity ,是number类型)isNaN(&apos;foo&apos;) //trueisNaN(&apos;10px&apos;) //truefunction isNumberic(num)&#123; return !isNaN(num)&#125; 复制数据12345let newRankListWithNewData = JSON.parse(JSON.stringify(this.state.rankList));let newMillisecondsOfTargets = this.state.millisecondsOfTargets.slice();(JavaScript Array slice() Method)(The slice() method returns a shallow copy) 字符串split分裂为数组12var str = &quot;How are you doing today&quot;;var res = str.split(&quot; &quot;) 数组concat合并两个数组1234var array1=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]var array2=[&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]console.log(array1.concat(array2));//(6) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 数组filter过滤生成新数组123456var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] 数组includes判断是否包含元素123456789101112var array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: truevar pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];console.log(pets.includes(&apos;cat&apos;));// expected output: trueconsole.log(pets.includes(&apos;at&apos;));// expected output: false 数组indexOf查找元素的下标1234567891011var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];console.log(beasts.indexOf(&apos;bison&apos;));// expected output: 1// start from index 2console.log(beasts.indexOf(&apos;bison&apos;, 2));// expected output: 4console.log(beasts.indexOf(&apos;giraffe&apos;));// expected output: -1 数组map对应生成新数组1234567var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32] 数组元素join合并为字符串12345678910var elements = [&apos;Fire&apos;, &apos;Air&apos;, &apos;Water&apos;];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(&apos;&apos;));// expected output: &quot;FireAirWater&quot;console.log(elements.join(&apos;-&apos;));// expected output: &quot;Fire-Air-Water&quot; 普通函数的this1.默认情况下（非严格模式），没有找到直接调用者，this指向window 2.严格模式（’use strict’），没有找到直接调用者，this是undefined 3.this总是代表它的直接调用者，比如：obj.fun，那么fun中的this是obj 4.使用call，apply，bind绑定的this指向的是绑定的对象 替换文本1234567891011&lt;script&gt;function escapeRegExp(string)&#123; return string.replace(/[.*+?^$&#123;&#125;()|[\]\\]/g, &quot;\\$&amp;&quot;);&#125;function replaceAll(str, term, replacement) &#123; return str.replace(new RegExp(escapeRegExp(term), &apos;g&apos;), replacement);&#125;a=&quot;test*SPACE*test&quot;;a=replaceAll(a,&quot;*SPACE*&quot;,&quot; &quot;)console.log(a); //test test&lt;/script&gt; 毫秒数值1234startTime = new Date().getTime();...endTime = new Date().getTime();const seconds = (endTime-startTime)/1000; 浏览器宽度123456789var x=window.innerWidth;if(x==undefined)&#123; x=document.documentElement.clientWidth;&#125;if(x==undefined)&#123; x=document.body.clientWidth;&#125; 箭头函数作为回调函数可用this123456789101112let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; console.log(this.myVar) setTimeout(() =&gt; &#123; console.log(this.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... foo 箭头函数语法1234567891011121314151617181920212223(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）// 当只有一个参数时，圆括号是可选的：(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125;//加括号的函数体返回对象字面表达式：参数=&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 ···]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F06%2F%E4%BB%8E%E4%BA%A7%E5%93%81%E8%A7%86%E8%A7%92%E5%88%86%E6%9E%90%E6%8B%BC%E5%A4%9A%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[1. 产品是什么？ 拼多多，致力于为最广大用户提供物有所值的商品和有趣互动购物体验的“新电子商务”平台 2. 目标用户与典型场景 案例一： 目标用户：家乡有特色农产品，但是苦于名声不显，而且地处偏僻。销量一般。 典型场景：西南农村年轻人小A没出去打工，但也见识过大城市的繁华，虽然回到家乡但内心也不甘寂寞，发现自己村里的蜜柑比城里的更好吃，又大又甜。在拼多多的大力推广中被这个平台吸引。于是在这个平台上开了一家小店，把乡亲们的农产品远销国内。 案例二： 目标用户：在大厂夹缝中生存的中小企业。虽然有产品，但是没有市场。 典型场景：江浙XX制造。在名牌效应下，大多数消费者更加信赖大厂，XX制造凭借价格和质量勉强在本市有了一定购众。收益不温不火。在拼多多这一平台上，凭借其低廉的价格，收拢了一大批受众。 案例三： 目标用户：经济条件一般的中低产阶级人群 典型场景：小B每月工资也不高，交完房租，一个月也没剩多少，过日子也需要精打细算。在拼多多上能用比较低的价格买到日用品。好用不贵。 3. 关键功能体验与描述： 深度体验拼多多APP的搜索、选择商品数量及型号、支付等基础功能，描述对应功能的作用，并通过思考以下内容，描述这些功能的设计细节： 功能相关入口有哪些，这些入口分别处于哪个位置 正常情况下，你是怎么使用这些功能的？ 尝试做一些非正常的使用动作，看看系统会如何处理这些异常情况。 其它：在基础购物功能之外，拼多多还有哪些「模块」或「功能」，会让你感觉比较有特色或者有亮点？请思考并描述这些亮点功能，并写下你认为这些功能是亮点的原因 回答： 3.1 拼单购物功能 （1）拼单功能： 功能作用： 多人拼单，在商家规定的时间内，达到拼单人数，能够获得价格优惠。在发起拼单后有三种方式寻找拼友。一是，发起拼单会推送至他人首页，如果此时他人正好有兴趣的话可以直接进入拼单。二是，发起拼单后拼团会在该商品页滚动循环。三是，将邀请发给家人、朋友、拼友群邀请他们一起购买。超时未达到拼单人数，拼单失败资金退回原有帐户。邀请方式不限于链接，可以面对面扫码，分享图片或者添加语音留言，提高可信度。 功能设计细节描述： 在商品页发起拼单功能按键比单独购买颜色更加醒目且体积更大，更加显眼。进入任一商品详情页，就能在显眼位置看见只差1人的拼单。吸引用户点击。入口多：首页、商品详情页、朋友的链接。都可以直达拼单。商品界面左上角会不断提示有用户已经拼单成功，提高用户购买信心。 拼单功能使用流程： 进入心仪商品的商品详情页——点击发起拼单——支付——将拼单链接分享给朋友——等待拼单完成 进入心仪商品详情页——在拼单列表中选择一个去拼单——支付——拼单完成 点击分享的链接——进入商品页——拼单——支付 ​ 支付页面与传统电商相比没有太大区别。在支付页面尽可能减少干扰，促使用户完成支付。但比传统电商在左上角多了一个“某用户拼单成功”、‘某用户几分钟前五星好评’、‘某用户正在拼这个商品’的提示，但无法点击跳转。同样是为了提高用户购买信心，促使用户下单购买。 ​ 拼购作为拼多多的核心功能，其中推广的潜在属性非常有效的且高明。所有用户都变成潜在的推广员，非常容易拉到新用户。并且以便宜的价格留存用户。 3.2 搜索功能 4. 竞品（对比拼多多和竞品各自的优缺点） ps：三节课产品实习生小三三对微信读书进行了分析，可以作为参考：【案例】从产品视角分析微信读书]]></content>
  </entry>
  <entry>
    <title><![CDATA[用electron制作你的第一个桌面应用]]></title>
    <url>%2F2019%2F06%2F05%2F%E7%94%A8electron%E5%88%B6%E4%BD%9C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron是什么？Electron由 Github 开发，使用Chromium和Node.js的跨平台桌面应用程序的框架。能够非常容易的使用HTML、CSS和JavaScript构建，并能与Mac、windows、linux兼容。 其他内置功能包括: 自动更新 本机菜单和通知 应用程序崩溃报告 调试和分析 Windows安装程序 本文章将制作一个简单的按键发声的electron应用。源码地址 在我们开始先，你需要安装Node.js。而且应该有一个Github账号来存储更新你的应用。 从这里开始当我们安装好node环境，并设置完毕后，打开操作终端窗口。 按照下面的方式快速启动一个electron。我们将在这个基础上构建我们的软件。 123456# 克隆示例项目的仓库git clone https://github.com/electron/electron-quick-start# 进入这个仓库cd electron-quick-start# 安装依赖并运行npm install &amp;&amp; npm start 当上面列出的步骤完成后，你会看到应用程序在浏览器窗口中打开。这确实是一个浏览器窗口。 正如前面所说，你可以在你的应用程序中使用Chrome的开发者工具。你可以用浏览器的开发者工具做什么，你也可以在应用程序中做什么。 Electron应用架构用你喜欢的IDE打开项目，来看看程序的源码和文件结构，这里使用的是Atom，同时它也是基于electron制作的。 现在就有了一个基本的文件结构 12345electron-quick-start- index.html- main.js- package.json- render.js 文件结构类似于我们创建网页时使用的文件结构。 index.html 如同页面开发一样，我们的主体，装载各种dom元素。 main.js 创建窗口并处理系统事件 package.json 是我们应用程序的启动脚本。它将在主进程中运行，并且包含关于我们的应用程序的信息 render.js 处理应用程序的渲染过程 你可能有一些关于主流程和渲染流程的问题。这是什么玩意，我该怎么用。因为如果你原来只擅长JavaScript，这可能是个新领域。 什么是进程当你看到“进程”时，想想操作系统级的进程。这是在系统中运行的计算机程序的一个实例。 如果启动Electron，并检查Windows任务管理器或者macOS的活动监视器，可以看到与我的应用程序相关的进程。 这些进程中的每一个都是并行运行的。但是分配给每个进程的内存和资源是相互隔离的。 比方说，我想创建一个for循环，在渲染过程中增加一些内容。 1234var a = 1;for ( a = 1; a &lt; 10; a ++) &#123; console.log(&apos;This is a for loop&apos;);&#125; 增量仅在渲染过程中可用。它根本不影响主要过程。This is a for loop这个信息只会出现在渲染模块上。 Main Process主进程控制应用程序的生命周期。它内置了完整的Node.js API，它打开对话框，并创建渲染过程。它还处理其他操作系统交互，并启动和退出应用程序。 按照惯例，这个过程在一个名为main.js的文件中，但是它可以有你想要的任何名称。 你也可以通过在package.json文件中修改主进程文件来改变它。 为了测试目的，打开package.json 将： 1“main”: “main.js”, 改成 1“main”: “mainTest.js”, 启动你的应用程序，看看它是否仍然有效。 请记住，只有一个Main Process。 Render Process渲染过程是应用程序中的浏览器窗口。与主进程不同，可以有许多渲染进程，每个进程都是独立的。 因为每个渲染过程都是独立的，所以一个渲染过程中的崩溃不会影响另一个渲染过程。这要归功于Chromium的多进程结构。 这些浏览器窗口也可以隐藏和定制，因为它们像HTML文件。 但是在Electron中，我们也有完整的node. js API。这意味着我们可以打开对话框和其他操作系统交互。 问题是，他们能以某种方式联系起来吗？ 这些进程同时独立运行。但是他们仍然需要以某种方式交流。尤其是因为他们负责不同的任务。 为此，有一个进程间通信系统或叫做IPC。您可以使用IPC在主进程和渲染进程之间传递消息。要更深入地解释这个系统，请阅读Christian Engvall的文章。 这些就是Electron开发的基本流程。 现在开始回到代码上。 个性化给文件夹起一个正确的名字。把 electron-quick-start改成 hear-me-type-tutorial。 package.json 包含关于我们的应用程序的重要信息。这是定义名称、版本、主文件、作者、许可证等等的地方。 找到下面的名称和描述，并在包中更改它们。 现在，我们的应用程序有了新的名称和简短但直截了当的描述。 记住，你总是可以在你的终端上运行npm start来执行应用程序，并查看你所做的更改。 现在开始添加我们预期的功能，按下每一个键盘，播放特定声音。 添加功能为了让应用程序对我们的输入做出反应，我们必须首先定义一个要挂钩的元素，然后触发所需的动作。 为此，我们将为我们想要的键盘按键创建带有特定标识的音频元素。然后，我们将创建一个switch语句来找出按下了哪个键盘键。然后，我们将播放分配给该键的特定声音 下载这个包含我们将要使用的所有声音文件的压缩包。我们很快就会利用它们！ 打开index.html文件，让我们创建元素，将声音内容嵌入到我们的应用程序中。 在 元素里创建一个 div 并加上audio的class。 在创建的div元素中，创建一个id为“A”、source为“sounds/A.mp3”、preload为“auto”的元素。 我们将使用preload=&quot;auto &quot;告诉应用程序，当页面加载时，它应该加载整个音频文件。index.html是应用程序的主文件，当应用程序执行时，我们所有的声音文件都会加载。 代码应该如下所示: 123&lt;div class=&quot;audio&quot;&gt;&lt;audio id=&quot;A&quot; src=&quot;sounds/A.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 现在， 指向一个未知的源文件。创建一个名为sounds的文件夹，并解压缩该文件夹中的所有声音文件。 现在唯一缺少的就是js代码。 创建一个名为functions.js的新文件。并在index.html文件中引入它，这样js代码就可以在应用程序运行时使用了。 添加下面这行代码： 1require(&apos;./functions.js&apos;) 此时项目如下图所示： 打开function.js文件，并将以下JavaScript代码添加到文件中。一会儿我会解释它是如何工作的。 123456789document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 65: document.getElementById(&apos;A&apos;).play(); break; default: console.log(&quot;Key is not found!&quot;); &#125;&#125;; 打开你的bash或终端窗口。确保你在项目的文件夹中，键入npm start 开始运行应用程序。 调整扬声器的音量，然后按键盘上的A按钮。 你就能听到一个女人的声音了。 JS代码非常简单明了。 我们使用 document 上的onkeydown事件来找出正在访问的HTML元素。请记住， document 是我们应用程序的主窗口。 在匿名函数中，我们使用switch语句。其目的是识别按下键盘键的Unicode值。 如果按下的键盘键的Unicode值正确，则会播放声音。否则，“not found”将引发错误。在控制台中查找消息。 接下来把所有键盘都给弄上声音吧。 打开index.html，为我们有声音文件的每个键创建一个元素。 代码应该如下所示: 1234567891011121314151617181920212223242526272829303132333435&lt;audio id=&quot;B&quot; src=&quot;sounds/B.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;C&quot; src=&quot;sounds/C.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;D&quot; src=&quot;sounds/D.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;E&quot; src=&quot;sounds/E.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;F&quot; src=&quot;sounds/F.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;G&quot; src=&quot;sounds/G.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;H&quot; src=&quot;sounds/H.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;I&quot; src=&quot;sounds/I.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;J&quot; src=&quot;sounds/J.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;K&quot; src=&quot;sounds/K.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;L&quot; src=&quot;sounds/L.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;M&quot; src=&quot;sounds/M.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;N&quot; src=&quot;sounds/N.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;O&quot; src=&quot;sounds/O.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;P&quot; src=&quot;sounds/P.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Q&quot; src=&quot;sounds/Q.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;R&quot; src=&quot;sounds/R.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;S&quot; src=&quot;sounds/S.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;T&quot; src=&quot;sounds/T.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;U&quot; src=&quot;sounds/U.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;V&quot; src=&quot;sounds/V.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;W&quot; src=&quot;sounds/W.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;X&quot; src=&quot;sounds/X.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Y&quot; src=&quot;sounds/Y.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Z&quot; src=&quot;sounds/Z.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;0&quot; src=&quot;sounds/0.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;1&quot; src=&quot;sounds/1.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;2&quot; src=&quot;sounds/2.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;3&quot; src=&quot;sounds/3.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;4&quot; src=&quot;sounds/4.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;5&quot; src=&quot;sounds/5.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;6&quot; src=&quot;sounds/6.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;7&quot; src=&quot;sounds/7.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;8&quot; src=&quot;sounds/8.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;9&quot; src=&quot;sounds/9.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt; 对functions.js做同样的事： 你可以在这个网站上找到字符代码(key codes)。（可能需要科学上网） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 48: document.getElementById(&apos;0&apos;).play(); break; case 49: document.getElementById(&apos;1&apos;).play(); break; case 50: document.getElementById(&apos;2&apos;).play(); break; case 51: document.getElementById(&apos;3&apos;).play(); break; case 52: document.getElementById(&apos;4&apos;).play(); break; case 53: document.getElementById(&apos;5&apos;).play(); break; case 54: document.getElementById(&apos;6&apos;).play(); break; case 55: document.getElementById(&apos;7&apos;).play(); break; case 56: document.getElementById(&apos;8&apos;).play(); break; case 57: document.getElementById(&apos;9&apos;).play(); break; case 65: document.getElementById(&apos;A&apos;).play(); break; case 66: document.getElementById(&apos;B&apos;).play(); break; case 67: document.getElementById(&apos;C&apos;).play(); break; case 68: document.getElementById(&apos;D&apos;).play(); break; case 69: document.getElementById(&apos;E&apos;).play(); break; case 70: document.getElementById(&apos;F&apos;).play(); break; case 71: document.getElementById(&apos;G&apos;).play(); break; case 72: document.getElementById(&apos;H&apos;).play(); break; case 73: document.getElementById(&apos;I&apos;).play(); break; case 74: document.getElementById(&apos;J&apos;).play(); break; case 75: document.getElementById(&apos;K&apos;).play(); break; case 76: document.getElementById(&apos;L&apos;).play(); break; case 77: document.getElementById(&apos;M&apos;).play(); break; case 78: document.getElementById(&apos;N&apos;).play(); break; case 79: document.getElementById(&apos;O&apos;).play(); break; case 80: document.getElementById(&apos;P&apos;).play(); break; case 81: document.getElementById(&apos;Q&apos;).play(); break; case 82: document.getElementById(&apos;R&apos;).play(); break; case 83: document.getElementById(&apos;S&apos;).play(); break; case 84: document.getElementById(&apos;T&apos;).play(); break; case 85: document.getElementById(&apos;U&apos;).play(); break; case 86: document.getElementById(&apos;V&apos;).play(); break; case 87: document.getElementById(&apos;W&apos;).play(); break; case 88: document.getElementById(&apos;X&apos;).play(); break; case 89: document.getElementById(&apos;Y&apos;).play(); break; case 90: document.getElementById(&apos;Z&apos;).play(); break; default: console.log(&quot;Key is not found!&quot;); &#125;&#125;; 现在我们的app完成了。 该应用程序的主要功能已经完成，但仍有工作要做！ 快结束了尽管该应用程序运行正常，但它仍然缺少一些东西。 例如，在index.html文件中，您可以更改应用程序的标题和主窗口的内容。还可以增加各种样式。 代码也不完美。我们有许多相同的代码可以优化和改进。这将导致代码行减少，对眼睛来说也不会那么痛苦。 重复代码是不好的做法。 试一试?好的软件必须经过彻底的测试。 我建议你先按下每一个键盘键看看发生了什么。 最好的情况是你会听到你在代码中指定的每个键盘键的声音。但是，当你尽可能快地连续按下多个键时，会发生什么呢？像Home和NumLock按钮这样甚至不应该被按下的按键呢？ 如果你最小化应用程序并试着按下一个键会怎么样？你听到声音了吗？当你没有选择应用程序窗口，按下键盘键，你还能听到任何声音吗？ 不幸的是，答案是否定的。 这种行为是因为electron的构建。它允许你像使用C#语言一样获得全局键，但是你不能注册单独的键击。这超出了electron的正常用例范围。 一行接一行地运行代码，并尝试破解它。看看正在发生什么，electron正在抛出什么样的错误。这个练习将帮助你更好地调试。如果你知道你的应用程序的缺陷，那么你就知道如何修复它们，使应用程序变得更好。 在function.js文件中，我特意使用了一个不推荐使用的JavaScript事件。你能认出它吗？ 一旦你找到它，我希望你考虑如何在不改变应用程序功能的情况下替换它。 使用不推荐的代码是一种不好的做法，可能会导致严重的错误，你甚至可能不知道存在。随时了解语言的文档，看看会有什么变化。永远保持最新。 翻译自原文地址]]></content>
  </entry>
</search>
