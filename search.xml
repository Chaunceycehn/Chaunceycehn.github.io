<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Object 的 toString 方法来揭示类型]]></title>
    <url>%2F2019%2F06%2F21%2F%E4%BD%BF%E7%94%A8-Object-%E7%9A%84-toString-%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%AD%E7%A4%BA%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[使用 Object 的 toString 方法来揭示类型大家都知道，一个普通对象被转化为字符串时为 [object Object]： 1234let obj = &#123;&#125;;alert(obj); // [object Object]alert(obj.toString()); // 同上 这也是它们的 toString 方法的实现如此。但是，toString 自有其潜质，可以让它变得更实用一点。甚至可以用来替代 instanceof，也可以视作为 typeof的增强版。 按照 规范 上所讲，内置的 toString 方法可以从对象中提取出来，以其他值作为上下文（context）对象进行调用，调用结果取决于传入的上下文对象。 如果传入的是 number 类型，返回 [object Number] 如果传入的是 boolean 类型，返回 [object Boolean] 如果传入 null，返回 [object Null] 传入 undefined，返回 [object Undefined] 传入数组，返回 [object Array] …等等（例如一些自定义类型） 下面进行阐述： 1234567// 保存 toString 方法的引用，方便后面使用let objectToString = Object.prototype.toString;// 猜猜是什么类型？let arr = [];alert( objectToString.call(arr) ); // [object Array] 这里用到了call方法来调用 this=arr 上下文的方法 objectToString。 toString 的内部算法会检查 this 对象，返回对应的结果。再来几个例子： 12345let s = Object.prototype.toString;alert( s.call(123) ); // [object Number]alert( s.call(null) ); // [object Null]alert( s.call(alert) ); // [object Function] Symbol.toStringTag对象的 toString 方法可以使用 Symbol.toStringTag 这个特殊的对象属性进行自定义输出。 举例说明： 12345let user = &#123; [Symbol.toStringTag]: "User"&#125;;alert( &#123;&#125;.toString.call(user) ); // [object User] 大部分和环境相关的对象也有这个属性。以下输出可能因浏览器不同而异： 123456// 环境相关对象和类的 toStringTag：alert( window[Symbol.toStringTag]); // windowalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequestalert( &#123;&#125;.toString.call(window) ); // [object Window]alert( &#123;&#125;.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest] 输出结果和 Symbol.toStringTag（前提是这个属性存在）一样，只不过被包裹进了 [object ...] 里。 这样一来，我们手头上就有了个“磕了药似的 typeof”，不仅能检测基本数据类型，就是内置对象类型也不在话下，更可贵的是还支持自定义。 所以，如果希望以字符串的形式获取内置对象类型信息，而不仅仅只是检测类型的话，可以用这个方法来替代 instanceof。 类型检测方式： 用于 返回 typeof 基本数据类型 string {}.toString 基本数据类型、内置对象以及包含 Symbol.toStringTag 属性的对象 string instanceof 任意对象 true/false 看样子，{}.toString 基本就是一增强版 typeof。 instanceof 在涉及多层类结构的场合中比较实用，这种情况下需要将类的继承关系考虑在内。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序：marquee组件]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9Amarquee%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[文字跑马灯组件部分 marquee.json 1234&#123; &quot;component&quot;: true, &quot;usingComponents&quot;: &#123;&#125;&#125; marquee.wxml 123456&lt;!--components/marquee.wxml--&gt;&lt;view class=&apos;marquee_container&apos;&gt; &lt;view class=&apos;marquee_text&apos; style=&apos;&#123;&#123; orientation &#125;&#125;:&#123;&#123; marqueeDistance &#125;&#125;px;font-size: &#123;&#123;size&#125;&#125;px;&apos;&gt; &#123;&#123; text &#125;&#125; &lt;/view&gt;&lt;/view&gt; marquee.wxss 1234567891011/* components/marquee.wxss */.marquee_container &#123; position: relative; width: 100%;&#125;.marquee_text &#123; position: absolute; white-space: nowrap; top: 0;&#125; marquee.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// components/marquee.jsComponent(&#123; /** * 组件的属性列表 */ properties: &#123; text: &#123; type: String, value: &apos;ILoveEwei&apos; &#125; &#125;, /** * 组件的初始数据 */ data: &#123; marqueePace: 1, marqueeDistance: 0, size: 14, orientation: &apos;left&apos;, interval: 20 &#125;, /** * 组件的方法列表 */ methods: &#123; _scrolling: function() &#123; var _this = this; var timer = setInterval(()=&gt; &#123; if(-_this.data.marqueeDistance &lt; _this.data.length) &#123; _this.setData(&#123; marqueeDistance: _this.data.marqueeDistance - _this.data.marqueePace &#125;) &#125; else &#123; clearInterval(timer); _this.setData(&#123; marqueeDistance: _this.data.windowWidth &#125;); _this._scrolling(); &#125; &#125;,_this.data.interval); &#125; &#125;, created: function() &#123; var _this = this; var length = _this.data.text.length * _this.data.size; var windowWidth = wx.getSystemInfoSync().windowWidth _this.setData(&#123; length: length, windowWidth: windowWidth &#125;); _this._scrolling(); &#125;&#125;) 引用 demo.json 12345&#123; &quot;usingComponents&quot;: &#123; &quot;marquee&quot;: &quot;../../components/marquee&quot; &#125;&#125; demo.wxml 1&lt;marquee text=&quot;我爱你我爱你我爱你&quot;&gt;&lt;/marquee&gt; 原文地址：https://www.jianshu.com/p/0ff03e5e942e]]></content>
      <tags>
        <tag>微信小程序 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css备忘录]]></title>
    <url>%2F2019%2F06%2F13%2Fcss%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[align-self12345&lt;div style=&quot;display:flex;align-items:center;background-color:blue;width:100px;height:100px&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div style=&quot;align-self:flex-end;&quot;&gt;3&lt;/div&gt;&lt;/div&gt; background-image设置1234567891011121314151617181920212223&lt;style&gt;#div1 &#123;width:300px;height:300px;background-color:yellow;background-image: url(&quot;https://www.baidu.com/img/bd_logo1.png&quot;);background-size: 100px 100px;background-position: center;background-repeat: no-repeat;&#125;#div2 &#123;width:300px;height:300px;background-color:green;background-image: url(&quot;https://www.baidu.com/img/bd_logo1.png&quot;);background-size: 100px 100px;background-position: calc(50% - 50px) 50%;background-repeat: no-repeat;&#125;&lt;/style&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; box-sizing border-box12345* &#123; box-sizing: border-box;&#125;The width and height properties include the content, padding, and border, but do not include the margin. break-inside12345break-inside: avoid-column;defines how page, column, or region breaks should behave calc var123456789101112max-width: calc(100vw - 16px);...height: calc(var(--nums) * (var(--item-height) + 2px) + var(--section-header-height));...height: var(--section-header-height);...transform: translateY(calc(var(--index) * (var(--item-height) + 2px)));...z-index: calc(var(--nums) - var(--index) + 1);...--percent-number: calc(var(--delay) * 100 / var(--max-delay));width: calc((100% - 85px) * var(--percent-number) / 100); column12345column-count: 2;column-gap: 20px;column-rule-style: solid;column-rule-width: 1px;column-rule-color: white; display flex12345p &#123; display: flex;&#125;The flex container becomes flexible by setting the display property to flex display inline-block12345display: inline-block;Compared to display: block, the major difference is that display: inline-block does not add a line-break after the element, so the element can sit next to other elements. filter blur123&lt;div style=&quot;font-size:80px;filter:blur(5px);&quot;&gt;AAAAA&lt;/div&gt; flex align-items.png flex center1234567891011121314151617181920212223&lt;style&gt;.box &#123; display: flex; align-items: center; justify-content: center; width:500px; height:300px; background-color:blue;&#125;.box div &#123; width: 100px; height: 100px; background-color:yellow;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container--&gt; flex justify-content.png flex-direction column12345678.header &#123; display: flex; flex-direction: column; padding: 0px 0px 10px 0px;&#125;column The flexible items are displayed vertically, as a column flex-direction row123flex-direction: row;row Default value. The flexible items are displayed horizontally, as a row float left.png float right123456789101112&lt;style&gt;.right &#123; float: right; width: 300px; border: 3px solid #73AD21; padding: 10px;&#125;&lt;/style&gt;&lt;div class=&quot;right&quot;&gt;In my younger and more vulnerable years my father gave me some advice that I&apos;ve been turning over in my mind ever since.&lt;/div&gt; img vertical-align middle123AAAAA&lt;br&gt;AAAAA&lt;img style=&quot;vertical-align:middle;&quot; src=&quot;https://mat1.gtimg.com/pingjs/ext2020/qqindex2018/dist/img/qq_logo_2x.png&quot;&gt;AAAAA&lt;br&gt;AAAAA inline-block middle1234567891011121314151617181920212223&lt;style&gt;.inner &#123; display: inline-block; vertical-align: middle; background: yellow; padding: 3px 5px;&#125;.block2 &#123; background: orange; height: 80px;&#125;.block2:before &#123; content: &quot;&quot;; display: inline-block; vertical-align: middle; height: 100%;&#125;&lt;/style&gt;&lt;div class=&quot;block2&quot;&gt;&lt;div class=&quot;inner&quot;&gt;Inline-Block&lt;/div&gt;&lt;div class=&quot;inner&quot;&gt;Inline-Block&lt;/div&gt;&lt;/div&gt; justify-content center123456789101112131415161718192021222324252627282930313233343536&lt;style&gt;* &#123;padding: 0;margin: 0;&#125;html, body &#123;height: 100%;&#125;ul &#123;height: 100%;&#125;li &#123;display: flex;justify-content: center;flex-direction: column;text-align: center;&#125;.first &#123;height: 20%;background: silver;&#125;.second &#123;height: 30%;background: lightgray;&#125;.third &#123;height: 30%;background: silver;&#125;&lt;/style&gt;&lt;ul&gt;&lt;li class=&quot;first&quot;&gt;This is the text&lt;/li&gt;&lt;li class=&quot;second&quot;&gt;This is text in a taller list item&lt;/li&gt;&lt;li class=&quot;third&quot;&gt;This is so much text that&lt;br&gt; it goes to a second line&lt;/li&gt;&lt;/ul&gt; line-height12345678910&lt;style&gt;div &#123; height: 90px; line-height: 90px; text-align: center; border: 2px dashed #f69c55;&#125;&lt;/style&gt;&lt;div&gt;Hello World!&lt;/div&gt; linear-gradient123456789&lt;style&gt;#div1 &#123; background-image: linear-gradient(to right, blue , yellow); width:300px; height:100px;&#125;&lt;/style&gt;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; margin 0 auto123456789101112margin: 0 auto;the object will sit centrally within it&apos;s parent container.margin-top:0;margin-bottom:0;margin-left:auto;margin-right:auto; opacity123456opacity: 0;opacity: 0.5;opacity 1(default) padding border margin.png position1234567891011121314relative The element is positioned according to the normal flow of the document, and then offset relative to itself based on the values of top, right, bottom, and left.absolute The element is removed from the normal document flow, and no space is created for the element in the page layout. It is positioned relative to its closest positioned ancestor fixed The element is removed from the normal document flow, and no space is created for the element in the page layout. It is positioned relative to the initial containing block established by the viewport relative不占用空间1234567891011121314151617181920&lt;style&gt;#box2&#123; position:relative; top:-50px; margin-bottom:-50px; width:100px; height:100px; background-color:gray; opacity:0.5; box-sizing:border-box; border:6px solid black;&#125;&lt;/style&gt;&lt;div style=&quot;width:100px;height:100px;background-color:blue;&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div style=&quot;width:100px;height:100px;background-color:yellow;&quot;&gt;&lt;/div&gt; relative里面的absolute.png row wrap nth-child1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;.container&#123;background: tomato;display: flex;flex-flow: row wrap;align-content: space-between;justify-content: space-between;&#125;.item&#123;width: 100px;background: gold;height: 100px;border: 1px solid black;font-size: 30px;line-height: 100px;text-align: center;margin: 10px&#125;.item:nth-child(3n)&#123;background: silver;&#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;item&quot;&gt;10&lt;/div&gt;&lt;/div&gt; space-between12345678910111213141516&lt;style&gt;.header &#123; background: #ccc; display: flex; justify-content: space-between;&#125;&lt;/style&gt;&lt;div class=&quot;header&quot;&gt; Title &lt;div class=&quot;nav&quot;&gt; &lt;a&gt;A Link&lt;/a&gt; &lt;a&gt;Another Link&lt;/a&gt; &lt;a&gt;A Third Link&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; space-evenly center123456789101112131415161718192021&lt;style&gt;#div1 &#123; display:flex; flex-direction:row; justify-content:space-evenly; align-items:center; width:500px; height:300px; background-color:blue;&#125;#div1 div &#123; background-color:yellow; margin:10px;&#125;&lt;/style&gt;&lt;div id=&quot;div1&quot;&gt; &lt;div&gt;111&lt;br&gt;111&lt;br&gt;111&lt;/div&gt; &lt;div&gt;222222&lt;br&gt;222222&lt;/div&gt; &lt;div&gt;333333333&lt;/div&gt;&lt;/div&gt; table-cell middle1234567891011121314151617&lt;style&gt;#parent &#123; display: table; width:300px; height:200px;&#125;#child &#123; display: table-cell; vertical-align: middle; background-color:yellow; text-align:center;&#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt;Content here&lt;/div&gt;&lt;/div&gt; transform-origin rotate1&lt;div style=&quot;transform-origin:center;transform:rotate(45deg);width:300px;height:300px;background-color:black;margin:300px;&quot;&gt;&lt;/div&gt; vw1vw Relative to 1% of the width of the viewport width max-width12345.content &#123; width: 95%; max-width: calc(100vw - 16px); margin: 0 auto;&#125; “伪元素”after1234/* Add an arrow after links */a::after &#123; content: &quot;→&quot;;&#125; 四个数值1234567【顺序是１２点，顺时针】padding: 25px 50px 75px 100px; top padding is 25px right padding is 50px bottom padding is 75px left padding is 100px 圆圈进度条1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;style&gt;.container&#123; width: 110px; height: 110px; margin: 100px auto;&#125;.prec&#123; top: 30px; position: relative; font-size: 30px;&#125;.circle&#123; position: relative; top: 5px; left: 5px; text-align: center; width: 100px; height: 100px; border-radius: 100%; background-color: #E6F4F7;&#125;.active-border&#123; position: relative; text-align: center; width: 110px; height: 110px; border-radius: 100%; background-color:#39B4CC; background-image: linear-gradient(91deg, transparent 50%, #A2ECFB 50%), linear-gradient(90deg, #A2ECFB 50%, transparent 50%);&#125;&lt;/style&gt;&lt;!-- &quot;180&quot; = 90+90, 90/360 = 25% --&gt;&lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;activeBorder&quot; class=&quot;active-border&quot; style=&quot;background-image:linear-gradient(180deg, transparent 50%, #A2ECFB 50%),linear-gradient(90deg, #A2ECFB 50%, transparent 50%);&quot;&gt; &lt;div id=&quot;circle&quot; class=&quot;circle&quot;&gt; &lt;span class=&quot;prec&quot; id=&quot;prec&quot;&gt;25%&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- &quot;180&quot; = 270-90, 270/360 = 75% --&gt;&lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;activeBorder&quot; class=&quot;active-border&quot; style=&quot;background-image:linear-gradient(180deg, transparent 50%, #39B4CC 50%),linear-gradient(90deg, #A2ECFB 50%, transparent 50%);&quot;&gt; &lt;div id=&quot;circle&quot; class=&quot;circle&quot;&gt; &lt;span class=&quot;prec&quot; id=&quot;prec&quot;&gt;75%&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!--if (i&lt;=180)&#123; activeBorder.css(&apos;background-image&apos;,&apos;linear-gradient(&apos; + (90+i) + &apos;deg, transparent 50%, #A2ECFB 50%),linear-gradient(90deg, #A2ECFB 50%, transparent 50%)&apos;);&#125;else&#123; activeBorder.css(&apos;background-image&apos;,&apos;linear-gradient(&apos; + (i-90) + &apos;deg, transparent 50%, #39B4CC 50%),linear-gradient(90deg, #A2ECFB 50%, transparent 50%)&apos;);&#125;--&gt;&lt;!--https://stackoverflow.com/questions/24393993/create-a-percentage-circle-with-csshttp://jsfiddle.net/zap4f/1/--&gt; 左上角右下角不同背景1234567&lt;style&gt;.a &#123; background:linear-gradient(to bottom right,blue 50%,yellow 50%);&#125;&lt;/style&gt;&lt;div class=&quot;a&quot; style=&quot;width:30px;height:30px;&quot;&gt;&lt;/a&gt; 底部居中固定12345678.notice &#123; position: fixed; bottom: 0px; left: 50%; width: 240px; margin-top: 0px; margin-left: -120px;... 指定子元素.A1234div.section&gt;div.list&gt;div.line &#123;...div.section&gt;div.list&gt;div.line&gt;div.bar &#123;... 指定子元素.B12section&gt;div &#123;... 指定标签和类12div.section &#123;... 文字居中1text-align: center; 普通position absolute.png 动画渐变123transition: all ease 1s;transition: all ease .5s; 粗体、斜体、下划线123font-weight: bold;font-style: italic;text-decoration: underline; 自动换行（打断单词）1overflow-wrap: break-word; 针对浏览器宽度123456789101112131415161718192021222324252627282930313233343536373839@media (min-width: 650px) and (max-width: 949px) &#123; #result &#123; column-count: 2; column-gap: 20px; column-rule-style: solid; column-rule-width: 1px; column-rule-color: white; &#125; .content &#123; width: 600px; &#125; .header &#123; display: flex; flex-direction: row; &#125; .title &#123; padding: 6px 0px 0px 0px; &#125;&#125;@media (min-width: 950px) &#123; #result &#123; column-count: 3; column-gap: 20px; column-rule-style: solid; column-rule-width: 1px; column-rule-color: white; &#125; .content &#123; width: 900px; &#125; .header &#123; display: flex; flex-direction: row; &#125; .title &#123; padding: 0px 0px 0px 0px; &#125;&#125; 链接123a:link, a:visited, a:hover, a:active &#123; color: LightBlue;&#125; 链接同样宽度123456.pagelink &#123; white-space: nowrap; margin-left: 15px; display: inline-block; width: 255px;&#125; 隐藏滚动条1overflow: hidden; 顶部居中固定12345678.message &#123; position: fixed; top: 0px; left: 50%; width: 200px; margin-top: 0px; margin-left: -100px;... 鼠标悬浮（字体和动画）1234567891011121314151617181920212223242526div.section&gt;div.list&gt;div.line&gt;span.name:hover span.tip &#123; animation: tipAnimation 5s ease forwards;&#125;div.section&gt;div.list&gt;div.line&gt;span.name:hover &#123; font-weight: bold; font-style: italic;&#125;@keyframes tipAnimation &#123; 10% &#123; visibility: visible; left: 140px; opacity:1; &#125; 60% &#123; visibility: visible; left: 140px; opacity: 1; &#125; 100% &#123; visibility: hidden; left: 140px; opacity: 0; &#125;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数的优点和缺点]]></title>
    <url>%2F2019%2F06%2F11%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[箭头函数的优点和缺点ES6标准新增了一种新的函数：Arrow Function（箭头函数） 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 举个例子，foo和bar在做同样的事情。 12345678let foo = function() &#123; console.log(&apos;BAZ&apos;)&#125;let bar = () =&gt; &#123; console.log(&apos;BAZ&apos;)&#125;foo() // BAZbar() // BAZ 但是箭头函数不仅仅是经典函数表达式的语法糖。我们可以发现两者之间有很大的区别。这些区别使箭头功能变得非常好用，但如果不小心，这可能就变成大坑。有时箭头函数不太管用，这时候依然需要使用经典的函数表达式。 箭头函数和this在经典函数表达式中，根据调用函数的上下文，this关键字绑定为不同的值。而箭头函数在其词法作用域内使用this。这导致了非常不同的行为。 上下文和作用域有什么区别？上下文(大致)是调用函数的对象。作用域是定义函数的所有变量。一个关心它是如何被调用的，另一个关心它是如何被定义的。 作为上下文的一个例子，定义一个对象，这个对象里有一个函数表达式方法。 12345678let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; console.log(this.myVar) &#125;&#125;obj.myFunc() // foo obj对象能调用myFunc函数，这就是myFunc的上下文。所以此时在myFuns中this的值被绑定为obj。根据函数的调用方式，可以用不同的方式定义上下文。例如，当用new关键字调用构造函数时，它的this被绑定到正在构造的新对象。context on MDN 因此，如果它绑定到上下文(即绑定到调用函数的对象)，它可能会导致回调出现一些非常棘手的问题。让我们在我们的对象my FuC中添加一个setTimeout来模拟回调: 123456789101112let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; console.log(this.myVar) setTimeout(function() &#123; console.log(this.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... undefined myFunc的this值取决于obj，因此，myFunc.myVar能够成功从foo打印出来。然而，第二个函数被setTimeout 调用，因此它的上下文不同。它的上下文实际上是节点中的超时对象或浏览器中的窗口对象，所以尽管我们可能依然想让他指向obj，但是已经失去了绑定。 此时需要一点小技巧。一种方法就是赋值给一个变量，通常我们命名为self或者that。这个变量在回调函数的词法范围内。这意味着回调函数可以访问该变量，因为它是在其范围内定义的: 12345678910111213let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; let self = this console.log(this.myVar) setTimeout(function() &#123; console.log(self.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... foo 也可以使用bind、call和apply等方法来实现这一点。 使用箭头函数有一个更简单的解决方案。回想一下，我们说过箭头函数从词法范围中获取它们的值。这意味着它只是在周围的代码块中使用这个值。它不在乎叫它什么，它只在乎它在哪里被定义 123456789101112let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; console.log(this.myVar) setTimeout(() =&gt; &#123; console.log(this.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... foo 因此，我们可以立即看到箭头函数更适合回调。但是如果我们尝试使用箭头函数作为对象方法会发生什么呢？ 12345678let obj = &#123; myVar: &apos;foo&apos;, myFunc: () =&gt; &#123; console.log(this.myVar) &#125;&#125;obj.myFunc() // undefined 你可能希望this指向obj。但是箭头函数不会将它绑定到调用它们的对象。他们只是在定义的范围内使用这个值。在这种情况下，this指向全局对象。所以箭头函数不能用于对象方法！ 要点:函数表达式适合对象方法。箭头函数适合回调或者map、reduce、forEach等方法。 您可以在MDN上阅读更多关于作用域的内容。从根本上讲，箭头函数根本无法将this的值与其作用域内的this值绑定。所以使用bind, call, 和 apply方法，没有任何影响。 构造方法箭头函数同样不适用于构造方法。经典的函数表达式可以用来构造这样一个新对象: 123456789let Person = function(name, height) &#123; this.name = name this.height = height&#125;Person.prototype.hello = function() &#123; console.log(&apos;Hi, my name is &apos; + this.name)&#125;let alice = new Person(&apos;Alice&apos;, 1.7)alice.hello() // Hi, my name is Alice 但是箭头函数没有prototype 原型。不能和new 绑定参数我们已经看到箭头函数如何不绑定this，它们只是在作用域中使用this。箭头函数也不绑定arguments对象。通过函数表达式，您可以做到这一点: 12345let sum = function() &#123; let args = Array.from(arguments) // arguments is available return args.reduce((a, b) =&gt; a + b, 0)&#125;sum(1, 2, 3) // 6 箭头函数没有arguments对象，但是使用rest参数也可以实现相同的功能:。 1234let sum4 = (...args) =&gt; &#123; return args.reduce((a, b) =&gt; a + b, 0)&#125;sum(1, 2, 3) // 6 隐式返回值我们可以用箭头函数使上面的函数更加简洁。使用简洁的形式，我们不必写一个代码块，只需定义一个表达式，箭头函数就会自动返回它的值: 1let sum = (...args) =&gt; args.reduce((a, b) =&gt; a + b, 0) 除此之外，我们可以通过用括号括起来返回对象文字: 1let getObj = () =&gt; (&#123; foo: &apos;hello&apos;, bar: &apos;world&apos; &#125;) 这种简洁的语法使得箭头函数在定义小而易读的回调时更好。 总结所以箭头函数与传统的函数表达式有很大不同。它们的一些特性，在作为回调函数时非常好用。但是它们很难用做对象方法和构造函数。还有一些其他的区别，例如，箭头函数不能是生成器。可以看去MDN上看到更多细节。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从产品视角分析拼多多]]></title>
    <url>%2F2019%2F06%2F11%2F%E4%BB%8E%E4%BA%A7%E5%93%81%E8%A7%86%E8%A7%92%E5%88%86%E6%9E%90%E6%8B%BC%E5%A4%9A%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[1. 产品是什么？ 拼多多，致力于为最广大用户提供物有所值的商品和有趣互动购物体验的“新电子商务”平台 2. 目标用户与典型场景 案例一： 目标用户：家乡有特色农产品，但是苦于名声不显，而且地处偏僻。销量一般。 典型场景：西南农村年轻人小A没出去打工，但也见识过大城市的繁华，虽然回到家乡但内心也不甘寂寞，发现自己村里的蜜柑比城里的更好吃，又大又甜。在拼多多的大力推广中被这个平台吸引。于是在这个平台上开了一家小店，把乡亲们的农产品远销国内。 案例二： 目标用户：在大厂夹缝中生存的中小企业。虽然有产品，但是没有市场。 典型场景：江浙XX制造。在名牌效应下，大多数消费者更加信赖大厂，XX制造凭借价格和质量勉强在本市有了一定购众。收益不温不火。在拼多多这一平台上，凭借其低廉的价格，收拢了一大批受众。 案例三： 目标用户：经济条件一般的中低产阶级人群 典型场景：小B每月工资也不高，交完房租，一个月也没剩多少，过日子也需要精打细算。在拼多多上能用比较低的价格买到日用品。好用不贵。 3. 关键功能体验与描述： 深度体验拼多多APP的搜索、选择商品数量及型号、支付等基础功能，描述对应功能的作用，并通过思考以下内容，描述这些功能的设计细节： 功能相关入口有哪些，这些入口分别处于哪个位置 正常情况下，你是怎么使用这些功能的？ 尝试做一些非正常的使用动作，看看系统会如何处理这些异常情况。 其它：在基础购物功能之外，拼多多还有哪些「模块」或「功能」，会让你感觉比较有特色或者有亮点？请思考并描述这些亮点功能，并写下你认为这些功能是亮点的原因 回答： 3.1 拼单购物功能 （1）拼单功能： 功能作用： 多人拼单，在商家规定的时间内，达到拼单人数，能够获得价格优惠。在发起拼单后有三种方式寻找拼友。一是，发起拼单会推送至他人首页，如果此时他人正好有兴趣的话可以直接进入拼单。二是，发起拼单后拼团会在该商品页滚动循环。三是，将邀请发给家人、朋友、拼友群邀请他们一起购买。超时未达到拼单人数，拼单失败资金退回原有帐户。邀请方式不限于链接，可以面对面扫码，分享图片或者添加语音留言，提高可信度。 功能设计细节描述： 在商品页发起拼单功能按键比单独购买颜色更加醒目且体积更大，更加显眼。进入任一商品详情页，就能在显眼位置看见只差1人的拼单。吸引用户点击。入口多：首页、商品详情页、朋友的链接。都可以直达拼单。商品界面左上角会不断提示有用户已经拼单成功，提高用户购买信心。 拼单功能使用流程： 进入心仪商品的商品详情页——点击发起拼单——支付——将拼单链接分享给朋友——等待拼单完成 进入心仪商品详情页——在拼单列表中选择一个去拼单——支付——拼单完成 点击分享的链接——进入商品页——拼单——支付 ​ 支付页面与传统电商相比没有太大区别。在支付页面尽可能减少干扰，促使用户完成支付。但比传统电商在左上角多了一个“某用户拼单成功”、‘某用户几分钟前五星好评’、‘某用户正在拼这个商品’的提示，但无法点击跳转。同样是为了提高用户购买信心，促使用户下单购买。 ​ 拼购作为拼多多的核心功能，其中推广的潜在属性非常有效的且高明。所有用户都变成潜在的推广员，非常容易拉到新用户。并且以便宜的价格留存用户。 3.2 搜索功能 4. 竞品（对比拼多多和竞品各自的优缺点） ps：三节课产品实习生小三三对微信读书进行了分析，可以作为参考：【案例】从产品视角分析微信读书]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js备忘录]]></title>
    <url>%2F2019%2F06%2F11%2Fjs%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[appendChild123let img = document.createElement(&quot;img&quot;)...resultArea.appendChild(img); classList contains1234567891011&lt;div id=&quot;div1&quot; class=&quot;class1 class3&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;script&gt;a=document.getElementById(&quot;div1&quot;);b=document.getElementById(&quot;div2&quot;);c=a.classList.contains(&quot;class1&quot;);d=a.classList.contains(&quot;class2&quot;);e=a.classList.contains(&quot;class3&quot;);b.textContent=c.toString()+&quot; &quot;+d.toString()+&quot; &quot;+e.toString();&lt;/script&gt; className123result.className = &quot;result&quot;;...name.className = &quot;name&quot;; CSS变量1task.line.parentElement.style.setProperty(&quot;--max-delay&quot;, maxDelay); for in123456var person = &#123;fname:&quot;jone&quot;,lname:&quot;Doe&quot;,age:25&#125;var text= &apos;&apos;var x;for(x in person)&#123; text +=person[x] + &quot;&quot;;&#125; forEach123456array.forEach(function (item, i) &#123;// The following code logs a line for each element in an array:// function logArrayElements(element, index, array) &#123;// console.log(&apos;a[&apos; + index + &apos;] = &apos; + element);// &#125;// HTML转换为文本12345&lt;script&gt;a=&quot;&lt;span&gt;AAAAA&lt;/span&gt;&lt;div&gt;BBBBB&lt;/div&gt;&quot;;a=a.replace(/&lt;(?:.|\n)*?&gt;/gm, &apos;&apos;);console.log(a);&lt;/script&gt; isNaN123const b = parseFloat(a.substring(i+1,j));if(isNaN(b)) &#123;... JSON格式12345678910111213141516data1 = &#123; Vultr: [&#123; name: &quot;Frankfurt&quot;, url: &quot;http://fra-de-ping.vultr.com/&quot;, download: &quot;http://fra-de-ping.vultr.com/vultr.com.100MB.bin&quot; &#125;, &#123; name: &quot;Amsterdam&quot;, url: &quot;http://ams-nl-ping.vultr.com/&quot;, download: &quot;http://ams-nl-ping.vultr.com/vultr.com.100MB.bin&quot; &#125;, ... &quot;EC2 (No Download)&quot;: [&#123; name: &quot;North Virginia&quot;, url: &quot;http://18.204.0.0/&quot; &#125;, ... Object.entries forEach123456789101112131415Object.entries(data).forEach(function (pair) &#123; // Object.entries... // const object2 = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; &#125;; // console.log(Object.entries(object2)[2]); // expected output: Array [&quot;2&quot;, &quot;c&quot;] // // forEach... // var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; // array1.forEach(function(element) &#123; // console.log(element); // &#125;); // expected output: &quot;a&quot; // expected output: &quot;b&quot; // expected output: &quot;c&quot; // Object.keys1234dataKeys = Object.keys(data);for(i=0;i&lt;=dataKeys.length-1;i++) &#123; dataEntry = data[dataKeys[i]];... parseInt1234&lt;script&gt;var n = parseInt(&quot;2018@geeksforgeeks&quot;);console.log(n); //2018&lt;/script&gt; push12345tasks.push(subtasks);// The push() method adds one or more elements// to the end of an array// and returns the new length of the array.// querySelector1const resultArea = document.querySelector(&quot;#result&quot;); querySelectorAll12345678910111213&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;&lt;script&gt;a=document.querySelectorAll(&quot;.a&quot;);for(i=0;i&lt;=a.length-1;i++) &#123; a[i].innerHTML=123;&#125;//123//123//123&lt;/script&gt; requestAnimationFrame1234567891011let nextTick = window.requestAnimationFrame || window.setTimeout// The delay function// The window.requestAnimationFrame() method tells the browser// that you wish to perform an animation and requests// that the browser call a specified function// to update an animation before the next repaint.//...function handleTasks() &#123;...nextTick(handleTasks); shift12345currentSubTasks = tasks.shift();...// The shift() method removes the first element// from an array and returns that removed element.// sort123newRankListSort.sort(function (a,b) &#123; return a.milliseconds - b.milliseconds;&#125;); splice1234567&lt;script&gt;var list = [&quot;foo&quot;, &quot;bar&quot;];list.splice(1, 0, &quot;baz&quot;, &quot;qux&quot;);console.log(list); // (4) [&quot;foo&quot;, &quot;baz&quot;, &quot;qux&quot;, &quot;bar&quot;]list.splice(1,2);console.log(list);//(2) [&quot;foo&quot;, &quot;bar&quot;]&lt;/script&gt; textContent12const el = document.createElement(tag);el.textContent = text; toFixed1document.getElementById(&quot;speed&quot;).innerText = (mb/seconds).toFixed(3).toString() + &quot; MBps&quot;; void(0)获取undefinedvoid 运算符 对给定的表达式进行求值，然后返回 undefined。 1void 0 === undefined //true undefined在JavaScript中并不属于保留字/关键字，因此在IE5.5~8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效） 这个运算符能向期望一个表达式的值是undefined的地方插入会产生副作用的表达式。 void 运算符通常只用于获取 undefined的原始值，一般使用void(0)（等同于void 0）。在上述情况中，也可以使用全局变量undefined来代替（假定其仍是默认值）。 “…”1Math.max(...this.state.millisecondsOfTargets) 保存this然后回调函数使用12345678910111213let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; let self = this console.log(this.myVar) setTimeout(function() &#123; console.log(self.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... foo 判断变量类型12345678910&lt;script&gt;a=&#123;&#125;;b=[];c=1;d=&quot;a&quot;;console.log(Object.prototype.toString.call(a)); //[object Object]console.log(Object.prototype.toString.call(b)); //[object Array]console.log(Object.prototype.toString.call(c)); //[object Number]console.log(Object.prototype.toString.call(d)); //[object String]&lt;/script&gt; 判断字符串是否为数字12345678910isNaN(num) //如果是数字的话返回falseisNaN(123) //falseisNaN(&apos;123&apos;) //falseisNaN(&apos;1e10000&apos;) //false (被转义成 Infinity ,是number类型)isNaN(&apos;foo&apos;) //trueisNaN(&apos;10px&apos;) //truefunction isNumberic(num)&#123; return !isNaN(num)&#125; 复制数据12345let newRankListWithNewData = JSON.parse(JSON.stringify(this.state.rankList));let newMillisecondsOfTargets = this.state.millisecondsOfTargets.slice();(JavaScript Array slice() Method)(The slice() method returns a shallow copy) 字符串split分裂为数组12var str = &quot;How are you doing today&quot;;var res = str.split(&quot; &quot;) 数组concat合并两个数组1234var array1=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]var array2=[&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]console.log(array1.concat(array2));//(6) [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 数组filter过滤生成新数组123456var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] 数组includes判断是否包含元素123456789101112var array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: truevar pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];console.log(pets.includes(&apos;cat&apos;));// expected output: trueconsole.log(pets.includes(&apos;at&apos;));// expected output: false 数组indexOf查找元素的下标1234567891011var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];console.log(beasts.indexOf(&apos;bison&apos;));// expected output: 1// start from index 2console.log(beasts.indexOf(&apos;bison&apos;, 2));// expected output: 4console.log(beasts.indexOf(&apos;giraffe&apos;));// expected output: -1 数组map对应生成新数组1234567var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32] 数组元素join合并为字符串12345678910var elements = [&apos;Fire&apos;, &apos;Air&apos;, &apos;Water&apos;];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(&apos;&apos;));// expected output: &quot;FireAirWater&quot;console.log(elements.join(&apos;-&apos;));// expected output: &quot;Fire-Air-Water&quot; 普通函数的this1.默认情况下（非严格模式），没有找到直接调用者，this指向window 2.严格模式（’use strict’），没有找到直接调用者，this是undefined 3.this总是代表它的直接调用者，比如：obj.fun，那么fun中的this是obj 4.使用call，apply，bind绑定的this指向的是绑定的对象 替换文本1234567891011&lt;script&gt;function escapeRegExp(string)&#123; return string.replace(/[.*+?^$&#123;&#125;()|[\]\\]/g, &quot;\\$&amp;&quot;);&#125;function replaceAll(str, term, replacement) &#123; return str.replace(new RegExp(escapeRegExp(term), &apos;g&apos;), replacement);&#125;a=&quot;test*SPACE*test&quot;;a=replaceAll(a,&quot;*SPACE*&quot;,&quot; &quot;)console.log(a); //test test&lt;/script&gt; 毫秒数值1234startTime = new Date().getTime();...endTime = new Date().getTime();const seconds = (endTime-startTime)/1000; 浏览器宽度123456789var x=window.innerWidth;if(x==undefined)&#123; x=document.documentElement.clientWidth;&#125;if(x==undefined)&#123; x=document.body.clientWidth;&#125; 箭头函数作为回调函数可用this123456789101112let obj = &#123; myVar: &apos;foo&apos;, myFunc: function() &#123; console.log(this.myVar) setTimeout(() =&gt; &#123; console.log(this.myVar) &#125;, 1000) &#125;&#125;obj.myFunc() // foo ... then... foo 箭头函数语法1234567891011121314151617181920212223(参数1, 参数2, …, 参数N) =&gt; &#123; 函数声明 &#125;//相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）// 当只有一个参数时，圆括号是可选的：(单一参数) =&gt; &#123;函数声明&#125;单一参数 =&gt; &#123;函数声明&#125;// 没有参数的函数应该写成一对圆括号。() =&gt; &#123;函数声明&#125;//加括号的函数体返回对象字面表达式：参数=&gt; (&#123;foo: bar&#125;)//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; &#123;函数声明&#125;(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; &#123;函数声明&#125;//同样支持参数列表解构let f = ([a, b] = [1, 2], &#123;x: c&#125; = &#123;x: a + b&#125;) =&gt; a + b + c;f(); // 6 truthy or falsy123All values are truthy except for: false, 0, &quot;&quot; (empty string), null, undefined, and NaN.this means that the string &quot;false&quot;, the string &quot;0&quot;, an empty object &#123;&#125;, and an empty array [] are all truthy.You can double check this by passing an object into the Boolean function(e.g. Boolean(&quot;0&quot;);). 修改数组的方法 方法 描述 是否改变原始数组 join() 该方法返回的是以指定分隔符分隔而成的字符串 否 push() / unshift() 该方法返回的是修改后数组的长度 是 pop() / shift() 该方法返回的是弹出的元素 是 sort() 该方法返回的是经过排序后的数组 是 reverse() 该方法返回的是经过反序后的数组 是 concat() 该方法返回的是合并后的数组 否 slice() 该方法返回的是截取的数组 否 splice() 该方法返回的是删除的元素组成的一个数组 是 indexOf() / lastIndexOf() 该方法返回的是指定项的索引值 否 map() 该方法返回的是每次函数调用结果组成的数组 否 | filter() | 该方法返回的是符合过滤条件的结果组成的数组 | 否 |hexo| reduce() | 该方法返回的是迭代函数处理后的值 | 否 || copyWithin() | 该方法将数组中指定位置的成员复制到本数组其他位置 | 是 | 字符串常用方法1234567891011121314151617181920212223242526272829303132333435363738var str=&quot;hello world&quot;;str.charAt(1) //e 返回给定位置的字符str.charcodeAt(1) //101 返回给定位置字符的字符编码str[1] //e ie8+cancat() //可以接受任意多个参数拼接成新的字符串，但不会改变原字符串slice() //截取字符串，接受一或两个参数(开始位置和结束位置)，接受负值时会将负值与字符串长度相加substring() //截取字符串，接受一或两个参数(开始位置和结束位置，会将较小的参数作为起始位置)，接受负值时会将负的参数转换为零substr() //截取字符串，接受一或两个参数(开始位置和截取的字符个数)，接受负值时会将第一个负的参数加上字符串长度，将第二个负的参数转换为0indexOf() //可接受两个参数，要查找的子字符串和查找起点(可选)，找到返回位置，找不到返回-1lastIndexOf() //从数组的末尾开始查找trim() //删除前置和后缀的空格 返回的是字符串的副本，原始字符串不变toLowerCase() //转小写toUpperCase() //转大写toLocaleLowerCase() //转小写，针对地区的方法toLocaleUpperCase() //转大写，针对地区的方法match() //接收一个参数，正则表达式或者RegExp对象search() //接受一个正则，返回字符串中第一个匹配项的索引，没有返回-1replace() //替换字符串。接受两个参数，第一个是一个字符串或者RegExp对象， //第二个参数是一个字符串或者函数。如果第一个参数是一个字符串， //那么只会替换第一个子字符串，要想替换所有唯一的方法就是提供一个 //正则表达式，指定全局g标志 //replace()方法的第二个参数也可以是一个函数 function(match,...,pos,originalText)&#123; match //模式的匹配项 ... //正则表达式定义了多个捕获组的情况下，是第二，三...匹配项 pos //模式的匹配项在字符串中的位置 originalText //原始字符串 &#125;split() //分割字符串，并返回一个数组。第一个参数接受一个分隔符(可以是字符串或者RegExp对象)， //可选的第二个参数用于指定返回数组的大小localeCompare() //比较两个字符串，如果字符串在字母表中应该排在字符串参数之前，返回一个负数。相等返回0，之后返回正数String.fromCharcode() //构造函数本身的静态方法，接收一个或多个字符编码，转换成字符串，与charCodeAt相反]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用electron制作你的第一个桌面应用]]></title>
    <url>%2F2019%2F06%2F05%2F%E7%94%A8electron%E5%88%B6%E4%BD%9C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Electron是什么？Electron由 Github 开发，使用Chromium和Node.js的跨平台桌面应用程序的框架。能够非常容易的使用HTML、CSS和JavaScript构建，并能与Mac、windows、linux兼容。 其他内置功能包括: 自动更新 本机菜单和通知 应用程序崩溃报告 调试和分析 Windows安装程序 本文章将制作一个简单的按键发声的electron应用。源码地址 在我们开始先，你需要安装Node.js。而且应该有一个Github账号来存储更新你的应用。 从这里开始当我们安装好node环境，并设置完毕后，打开操作终端窗口。 按照下面的方式快速启动一个electron。我们将在这个基础上构建我们的软件。 123456# 克隆示例项目的仓库git clone https://github.com/electron/electron-quick-start# 进入这个仓库cd electron-quick-start# 安装依赖并运行npm install &amp;&amp; npm start 当上面列出的步骤完成后，你会看到应用程序在浏览器窗口中打开。这确实是一个浏览器窗口。 正如前面所说，你可以在你的应用程序中使用Chrome的开发者工具。你可以用浏览器的开发者工具做什么，你也可以在应用程序中做什么。 Electron应用架构用你喜欢的IDE打开项目，来看看程序的源码和文件结构，这里使用的是Atom，同时它也是基于electron制作的。 现在就有了一个基本的文件结构 12345electron-quick-start- index.html- main.js- package.json- render.js 文件结构类似于我们创建网页时使用的文件结构。 index.html 如同页面开发一样，我们的主体，装载各种dom元素。 main.js 创建窗口并处理系统事件 package.json 是我们应用程序的启动脚本。它将在主进程中运行，并且包含关于我们的应用程序的信息 render.js 处理应用程序的渲染过程 你可能有一些关于主流程和渲染流程的问题。这是什么玩意，我该怎么用。因为如果你原来只擅长JavaScript，这可能是个新领域。 什么是进程当你看到“进程”时，想想操作系统级的进程。这是在系统中运行的计算机程序的一个实例。 如果启动Electron，并检查Windows任务管理器或者macOS的活动监视器，可以看到与我的应用程序相关的进程。 这些进程中的每一个都是并行运行的。但是分配给每个进程的内存和资源是相互隔离的。 比方说，我想创建一个for循环，在渲染过程中增加一些内容。 1234var a = 1;for ( a = 1; a &lt; 10; a ++) &#123; console.log(&apos;This is a for loop&apos;);&#125; 增量仅在渲染过程中可用。它根本不影响主要过程。This is a for loop这个信息只会出现在渲染模块上。 Main Process主进程控制应用程序的生命周期。它内置了完整的Node.js API，它打开对话框，并创建渲染过程。它还处理其他操作系统交互，并启动和退出应用程序。 按照惯例，这个过程在一个名为main.js的文件中，但是它可以有你想要的任何名称。 你也可以通过在package.json文件中修改主进程文件来改变它。 为了测试目的，打开package.json 将： 1“main”: “main.js”, 改成 1“main”: “mainTest.js”, 启动你的应用程序，看看它是否仍然有效。 请记住，只有一个Main Process。 Render Process渲染过程是应用程序中的浏览器窗口。与主进程不同，可以有许多渲染进程，每个进程都是独立的。 因为每个渲染过程都是独立的，所以一个渲染过程中的崩溃不会影响另一个渲染过程。这要归功于Chromium的多进程结构。 这些浏览器窗口也可以隐藏和定制，因为它们像HTML文件。 但是在Electron中，我们也有完整的node. js API。这意味着我们可以打开对话框和其他操作系统交互。 问题是，他们能以某种方式联系起来吗？ 这些进程同时独立运行。但是他们仍然需要以某种方式交流。尤其是因为他们负责不同的任务。 为此，有一个进程间通信系统或叫做IPC。您可以使用IPC在主进程和渲染进程之间传递消息。要更深入地解释这个系统，请阅读Christian Engvall的文章。 这些就是Electron开发的基本流程。 现在开始回到代码上。 个性化给文件夹起一个正确的名字。把 electron-quick-start改成 hear-me-type-tutorial。 package.json 包含关于我们的应用程序的重要信息。这是定义名称、版本、主文件、作者、许可证等等的地方。 找到下面的名称和描述，并在包中更改它们。 现在，我们的应用程序有了新的名称和简短但直截了当的描述。 记住，你总是可以在你的终端上运行npm start来执行应用程序，并查看你所做的更改。 现在开始添加我们预期的功能，按下每一个键盘，播放特定声音。 添加功能为了让应用程序对我们的输入做出反应，我们必须首先定义一个要挂钩的元素，然后触发所需的动作。 为此，我们将为我们想要的键盘按键创建带有特定标识的音频元素。然后，我们将创建一个switch语句来找出按下了哪个键盘键。然后，我们将播放分配给该键的特定声音 下载这个包含我们将要使用的所有声音文件的压缩包。我们很快就会利用它们！ 打开index.html文件，让我们创建元素，将声音内容嵌入到我们的应用程序中。 在 元素里创建一个 div 并加上audio的class。 在创建的div元素中，创建一个id为“A”、source为“sounds/A.mp3”、preload为“auto”的元素。 我们将使用preload=&quot;auto &quot;告诉应用程序，当页面加载时，它应该加载整个音频文件。index.html是应用程序的主文件，当应用程序执行时，我们所有的声音文件都会加载。 代码应该如下所示: 123&lt;div class=&quot;audio&quot;&gt;&lt;audio id=&quot;A&quot; src=&quot;sounds/A.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 现在， 指向一个未知的源文件。创建一个名为sounds的文件夹，并解压缩该文件夹中的所有声音文件。 现在唯一缺少的就是js代码。 创建一个名为functions.js的新文件。并在index.html文件中引入它，这样js代码就可以在应用程序运行时使用了。 添加下面这行代码： 1require(&apos;./functions.js&apos;) 此时项目如下图所示： 打开function.js文件，并将以下JavaScript代码添加到文件中。一会儿我会解释它是如何工作的。 123456789document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 65: document.getElementById(&apos;A&apos;).play(); break; default: console.log(&quot;Key is not found!&quot;); &#125;&#125;; 打开你的bash或终端窗口。确保你在项目的文件夹中，键入npm start 开始运行应用程序。 调整扬声器的音量，然后按键盘上的A按钮。 你就能听到一个女人的声音了。 JS代码非常简单明了。 我们使用 document 上的onkeydown事件来找出正在访问的HTML元素。请记住， document 是我们应用程序的主窗口。 在匿名函数中，我们使用switch语句。其目的是识别按下键盘键的Unicode值。 如果按下的键盘键的Unicode值正确，则会播放声音。否则，“not found”将引发错误。在控制台中查找消息。 接下来把所有键盘都给弄上声音吧。 打开index.html，为我们有声音文件的每个键创建一个元素。 代码应该如下所示: 1234567891011121314151617181920212223242526272829303132333435&lt;audio id=&quot;B&quot; src=&quot;sounds/B.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;C&quot; src=&quot;sounds/C.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;D&quot; src=&quot;sounds/D.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;E&quot; src=&quot;sounds/E.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;F&quot; src=&quot;sounds/F.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;G&quot; src=&quot;sounds/G.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;H&quot; src=&quot;sounds/H.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;I&quot; src=&quot;sounds/I.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;J&quot; src=&quot;sounds/J.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;K&quot; src=&quot;sounds/K.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;L&quot; src=&quot;sounds/L.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;M&quot; src=&quot;sounds/M.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;N&quot; src=&quot;sounds/N.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;O&quot; src=&quot;sounds/O.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;P&quot; src=&quot;sounds/P.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Q&quot; src=&quot;sounds/Q.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;R&quot; src=&quot;sounds/R.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;S&quot; src=&quot;sounds/S.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;T&quot; src=&quot;sounds/T.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;U&quot; src=&quot;sounds/U.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;V&quot; src=&quot;sounds/V.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;W&quot; src=&quot;sounds/W.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;X&quot; src=&quot;sounds/X.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Y&quot; src=&quot;sounds/Y.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;Z&quot; src=&quot;sounds/Z.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;0&quot; src=&quot;sounds/0.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;1&quot; src=&quot;sounds/1.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;2&quot; src=&quot;sounds/2.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;3&quot; src=&quot;sounds/3.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;4&quot; src=&quot;sounds/4.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;5&quot; src=&quot;sounds/5.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;6&quot; src=&quot;sounds/6.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;7&quot; src=&quot;sounds/7.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;8&quot; src=&quot;sounds/8.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;&lt;audio id=&quot;9&quot; src=&quot;sounds/9.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt; 对functions.js做同样的事： 你可以在这个网站上找到字符代码(key codes)。（可能需要科学上网） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 48: document.getElementById(&apos;0&apos;).play(); break; case 49: document.getElementById(&apos;1&apos;).play(); break; case 50: document.getElementById(&apos;2&apos;).play(); break; case 51: document.getElementById(&apos;3&apos;).play(); break; case 52: document.getElementById(&apos;4&apos;).play(); break; case 53: document.getElementById(&apos;5&apos;).play(); break; case 54: document.getElementById(&apos;6&apos;).play(); break; case 55: document.getElementById(&apos;7&apos;).play(); break; case 56: document.getElementById(&apos;8&apos;).play(); break; case 57: document.getElementById(&apos;9&apos;).play(); break; case 65: document.getElementById(&apos;A&apos;).play(); break; case 66: document.getElementById(&apos;B&apos;).play(); break; case 67: document.getElementById(&apos;C&apos;).play(); break; case 68: document.getElementById(&apos;D&apos;).play(); break; case 69: document.getElementById(&apos;E&apos;).play(); break; case 70: document.getElementById(&apos;F&apos;).play(); break; case 71: document.getElementById(&apos;G&apos;).play(); break; case 72: document.getElementById(&apos;H&apos;).play(); break; case 73: document.getElementById(&apos;I&apos;).play(); break; case 74: document.getElementById(&apos;J&apos;).play(); break; case 75: document.getElementById(&apos;K&apos;).play(); break; case 76: document.getElementById(&apos;L&apos;).play(); break; case 77: document.getElementById(&apos;M&apos;).play(); break; case 78: document.getElementById(&apos;N&apos;).play(); break; case 79: document.getElementById(&apos;O&apos;).play(); break; case 80: document.getElementById(&apos;P&apos;).play(); break; case 81: document.getElementById(&apos;Q&apos;).play(); break; case 82: document.getElementById(&apos;R&apos;).play(); break; case 83: document.getElementById(&apos;S&apos;).play(); break; case 84: document.getElementById(&apos;T&apos;).play(); break; case 85: document.getElementById(&apos;U&apos;).play(); break; case 86: document.getElementById(&apos;V&apos;).play(); break; case 87: document.getElementById(&apos;W&apos;).play(); break; case 88: document.getElementById(&apos;X&apos;).play(); break; case 89: document.getElementById(&apos;Y&apos;).play(); break; case 90: document.getElementById(&apos;Z&apos;).play(); break; default: console.log(&quot;Key is not found!&quot;); &#125;&#125;; 现在我们的app完成了。 该应用程序的主要功能已经完成，但仍有工作要做！ 快结束了尽管该应用程序运行正常，但它仍然缺少一些东西。 例如，在index.html文件中，您可以更改应用程序的标题和主窗口的内容。还可以增加各种样式。 代码也不完美。我们有许多相同的代码可以优化和改进。这将导致代码行减少，对眼睛来说也不会那么痛苦。 重复代码是不好的做法。 试一试?好的软件必须经过彻底的测试。 我建议你先按下每一个键盘键看看发生了什么。 最好的情况是你会听到你在代码中指定的每个键盘键的声音。但是，当你尽可能快地连续按下多个键时，会发生什么呢？像Home和NumLock按钮这样甚至不应该被按下的按键呢？ 如果你最小化应用程序并试着按下一个键会怎么样？你听到声音了吗？当你没有选择应用程序窗口，按下键盘键，你还能听到任何声音吗？ 不幸的是，答案是否定的。 这种行为是因为electron的构建。它允许你像使用C#语言一样获得全局键，但是你不能注册单独的键击。这超出了electron的正常用例范围。 一行接一行地运行代码，并尝试破解它。看看正在发生什么，electron正在抛出什么样的错误。这个练习将帮助你更好地调试。如果你知道你的应用程序的缺陷，那么你就知道如何修复它们，使应用程序变得更好。 在function.js文件中，我特意使用了一个不推荐使用的JavaScript事件。你能认出它吗？ 一旦你找到它，我希望你考虑如何在不改变应用程序功能的情况下替换它。 使用不推荐的代码是一种不好的做法，可能会导致严重的错误，你甚至可能不知道存在。随时了解语言的文档，看看会有什么变化。永远保持最新。 翻译自原文地址]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
</search>
